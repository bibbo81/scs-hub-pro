<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supply Chain Hub - Tracking Spedizioni</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23007AFF'%3E%3Cpath d='M20 8h-3V4H3c-1.1 0-2 .9-2 2v11h2c0 1.66 1.34 3 3 3s3-1.34 3-3h6c0 1.66 1.34 3 3 3s3-1.34 3-3h2v-5l-4zM6 18.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm13.5-9l1.96 2.5H17V9.5h2.5zm-1.5 9c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z'/%3E%3C/svg%3E">
    
    <!-- Core CSS -->
    <link rel="stylesheet" href="/assets/css/solarium.css">
    <link rel="stylesheet" href="/assets/css/timeline.css">
    
    <!-- External Dependencies -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    
    <!-- Core JS Modules - ES6 -->
    <script type="module">
        // Import core modules
        import api from '/core/api-client.js';
        import headerComponent from '/core/header-component.js';
        import notificationSystem from '/core/notification-system.js';
        import modalSystem from '/core/modal-system.js';
        import TableManager from '/core/table-manager.js';
        import app from '/assets/js/app.js';
        
        // Make modules available globally for backward compatibility
        window.api = api;
        window.headerComponent = headerComponent;
        window.NotificationSystem = notificationSystem;
        window.ModalSystem = modalSystem;
        window.TableManager = TableManager;
        window.App = app;
    </script>
    
    <!-- Legacy Scripts (to be converted) -->
    <script src="/core/auth.js"></script> <!-- Mock auth system -->
    <script src="/core/auth-init.js"></script> <!-- IIFE, carica window.authInit -->
    <script src="/core/import-manager.js"></script> <!-- IIFE, carica window.ImportManager -->
    
    <!-- Mock Data - SOLO SVILUPPO - RIMUOVERE IN PRODUZIONE -->
    <script src="/core/mock-data.js"></script>
    
    <!-- Page Specific -->
    <script type="module" src="/pages/tracking/index.js"></script>
</head>
<body>
    <!-- Header verrà montato automaticamente da header-component.js -->
    
    <!-- Main Content -->
    <main class="sol-main-content" id="mainContent">
        <!-- Page Header -->
        <div class="sol-page-header">
            <div>
                <h1 class="sol-page-title">Tracking Spedizioni</h1>
                <p class="sol-page-subtitle">Monitora in tempo reale container, BL e spedizioni aeree</p>
            </div>
            <div class="sol-page-actions">
                <button class="sol-btn sol-btn-glass" id="refreshAllBtn">
                    <i class="fas fa-sync-alt"></i>
                    <span>Aggiorna Tutto</span>
                </button>
                <button class="sol-btn sol-btn-glass" id="exportPdfBtn">
                    <i class="fas fa-file-pdf"></i>
                    <span>Export PDF</span>
                </button>
                <button class="sol-btn sol-btn-glass" id="exportExcelBtn">
                    <i class="fas fa-file-excel"></i>
                    <span>Export Excel</span>
                </button>
                <button class="sol-btn sol-btn-primary" id="addTrackingBtn">
                    <i class="fas fa-plus"></i>
                    <span>Aggiungi Tracking</span>
                </button>
            </div>
        </div>

        <!-- Stats Cards -->
        <div class="sol-stats-grid" id="statsGrid">
            <!-- Populated by JS -->
        </div>

        <!-- Add Tracking Form -->
        <div class="sol-card" id="addTrackingForm" style="display: none;">
            <!-- Populated by JS -->
        </div>

        <!-- Tracking List -->
        <div class="sol-card">
            <div class="sol-card-header">
                <h3 class="sol-card-title">Lista Tracking Attivi</h3>
                <div class="sol-card-filters">
                    <select class="sol-select" id="statusFilter">
                        <option value="">Tutti gli stati</option>
                        <option value="registered">Registrato</option>
                        <option value="in_transit">In Transito</option>
                        <option value="delivered">Consegnato</option>
                        <option value="delayed">In Ritardo</option>
                    </select>
                    <select class="sol-select" id="typeFilter">
                        <option value="">Tutti i tipi</option>
                        <option value="container">Container</option>
                        <option value="bl">Bill of Lading</option>
                        <option value="awb">Air Waybill</option>
                        <option value="parcel">Parcel</option>
                    </select>
                    <!-- View Toggle Button -->
                    <button type="button" class="sol-btn-toggle-view" id="toggleView" data-view="table">
                        <i class="fas fa-table"></i>
                        <span class="toggle-text">Vista Tabella</span>
                    </button>
                </div>
            </div>
            
            <div id="trackingTableContainer">
                <!-- Table Manager will render here -->
            </div>
            
            <!-- Timeline Container (nascosto di default) -->
            <div id="timelineContainer" class="sol-timeline-container" style="display: none;">
                <div class="sol-timeline-header">
                    <div class="sol-timeline-legend">
                        <span class="legend-item">
                            <i class="fas fa-circle text-info"></i> In Transit
                        </span>
                        <span class="legend-item">
                            <i class="fas fa-circle text-success"></i> Consegnato
                        </span>
                        <span class="legend-item">
                            <i class="fas fa-circle text-warning"></i> In Ritardo
                        </span>
                        <span class="legend-item">
                            <i class="fas fa-circle text-danger"></i> Problema
                        </span>
                    </div>
                </div>
                
                <div id="timelineContent" class="sol-timeline-content">
                    <!-- Timeline items verranno inseriti qui dinamicamente -->
                </div>
            </div>
        </div>
    </main>

<!-- Aggiungi questo SUBITO DOPO <body> in tracking.html, PRIMA di tutti gli altri script -->
<script>
// EARLY MOCK INTERCEPTOR - Deve essere caricato PRIMA di tutto
(function() {
    console.log('[EarlyMock] Setting up early interceptors...');
    
    // Crea un proxy per window.api prima che venga creato
    let realApi = null;
    let apiProxy = null;
    
    // Mock data per risposte immediate
    const mockResponses = {
        notifications: {
            notifications: [
                {
                    id: 1,
                    type: 'shipment',
                    title: 'Spedizione in arrivo',
                    message: 'Container MSKU1234567 arriverà domani',
                    read: false,
                    created_at: new Date().toISOString()
                },
                {
                    id: 2,
                    type: 'warning',
                    title: 'Ritardo spedizione',
                    message: 'BL MSCU7654321 è in ritardo di 2 giorni',
                    read: false,
                    created_at: new Date(Date.now() - 86400000).toISOString()
                }
            ],
            unread_count: 2,
            total: 2
        }
    };
    
    // Intercetta la definizione di window.api
    Object.defineProperty(window, 'api', {
        get: function() {
            return apiProxy;
        },
        set: function(value) {
            console.log('[EarlyMock] window.api is being set');
            realApi = value;
            
            // Crea proxy con interceptors
            apiProxy = new Proxy(realApi, {
                get: function(target, prop) {
                    if (prop === 'get') {
                        return async function(endpoint, options) {
                            console.log('[EarlyMock] Intercepting GET:', endpoint);
                            
                            // Se è una richiesta di notifiche, ritorna mock data immediato
                            if (endpoint.includes('notifications')) {
                                console.log('[EarlyMock] Returning mock notifications');
                                await new Promise(resolve => setTimeout(resolve, 100));
                                return mockResponses.notifications;
                            }
                            
                            // Altrimenti usa MockData se disponibile
                            if (window.MockData?.enabled) {
                                const mockData = window.MockData.interceptAPI(endpoint);
                                if (mockData) {
                                    console.log('[EarlyMock] Returning MockData for:', endpoint);
                                    await new Promise(resolve => setTimeout(resolve, 200));
                                    return mockData;
                                }
                            }
                            
                            // Fallback alla chiamata originale
                            try {
                                return await target.get.call(target, endpoint, options);
                            } catch (error) {
                                console.log('[EarlyMock] Original call failed:', error.message);
                                // Return empty data per 404
                                if (error.status === 404) {
                                    if (endpoint.includes('notifications')) {
                                        return { notifications: [], unread_count: 0 };
                                    }
                                    if (endpoint.includes('trackings')) {
                                        return { trackings: [], stats: {} };
                                    }
                                }
                                throw error;
                            }
                        };
                    }
                    
                    if (prop === 'post') {
                        return async function(endpoint, data, options) {
                            console.log('[EarlyMock] Intercepting POST:', endpoint);
                            
                            if (window.MockData?.enabled) {
                                await new Promise(resolve => setTimeout(resolve, 300));
                                return { success: true, message: 'Mock operation completed', data: data };
                            }
                            
                            return target.post.call(target, endpoint, data, options);
                        };
                    }
                    
                    // Per altre proprietà/metodi, ritorna l'originale
                    return target[prop];
                }
            });
        }
    });
    
    console.log('[EarlyMock] Early interceptor ready');
})();
</script>

    <!-- Fix Scripts -->
    <script>
    // Fix 1: Inizializzazione tracking
    window.addEventListener('DOMContentLoaded', function() {
        console.log('[Tracking Fix] Checking initialization...');
        
        // Attendi che trackingInit sia disponibile
        let attempts = 0;
        const initInterval = setInterval(() => {
            attempts++;
            
            if (window.trackingInit) {
                // Verifica se già inizializzato
                if (typeof window.showAddTrackingForm === 'undefined') {
                    console.log('[Tracking Fix] Calling trackingInit...');
                    window.trackingInit();
                }
                clearInterval(initInterval);
            } else if (attempts > 30) { // 3 secondi
                console.error('[Tracking Fix] trackingInit not found');
                clearInterval(initInterval);
            }
        }, 100);
    });

    // Fix 2: ModalSystem confirm
    setTimeout(() => {
        if (window.ModalSystem && !window.ModalSystem._confirmResolvers) {
            console.log('[Modal Fix] Patching ModalSystem.confirm...');
            
            window.ModalSystem._confirmResolvers = {};
            
            const originalConfirm = window.ModalSystem.confirm;
            window.ModalSystem.confirm = function(options = {}) {
                return new Promise((resolve) => {
                    const modalId = `modal-confirm-${Date.now()}`;
                    
                    const modal = this.create({
                        title: options.title || 'Conferma',
                        content: options.message || 'Sei sicuro?',
                        maxWidth: options.maxWidth || '500px',
                        footer: `
                            <button class="sol-btn sol-btn-glass" onclick="window.ModalSystem.handleConfirm('${modalId}', false)">
                                ${options.cancelText || 'Annulla'}
                            </button>
                            <button class="sol-btn ${options.confirmClass || 'sol-btn-primary'}" onclick="window.ModalSystem.handleConfirm('${modalId}', true)">
                                ${options.confirmText || 'Conferma'}
                            </button>
                        `,
                        hideClose: true,
                        closeOnBackdrop: false,
                        closeOnEsc: false
                    });
                    
                    this._confirmResolvers[modalId] = resolve;
                });
            };
            
            window.ModalSystem.handleConfirm = function(modalId, result) {
                const resolve = this._confirmResolvers?.[modalId];
                if (resolve) {
                    resolve(result);
                    delete this._confirmResolvers[modalId];
                }
                this.close(modalId);
            };
        }
    }, 1000);
    </script>

    <!-- Timeline Enhancement Script -->
    <script>
    // Timeline View Functions
    (function() {
        let currentView = 'table';
        
        // Initialize view toggle
        function initViewToggle() {
            const toggleBtn = document.getElementById('toggleView');
            const tableContainer = document.getElementById('trackingTableContainer');
            const timelineContainer = document.getElementById('timelineContainer');
            
            if (!toggleBtn) return;
            
            toggleBtn.addEventListener('click', function() {
                currentView = this.dataset.view === 'table' ? 'timeline' : 'table';
                
                if (currentView === 'timeline') {
                    // Switch to Timeline View
                    tableContainer.style.display = 'none';
                    timelineContainer.style.display = 'block';
                    
                    this.dataset.view = 'timeline';
                    this.classList.add('timeline-active');
                    this.innerHTML = '<i class="fas fa-stream"></i> <span class="toggle-text">Vista Timeline</span>';
                    
                    // Load timeline view
                    loadTimelineView();
                    
                } else {
                    // Switch back to Table View
                    tableContainer.style.display = 'block';
                    timelineContainer.style.display = 'none';
                    
                    this.dataset.view = 'table';
                    this.classList.remove('timeline-active');
                    this.innerHTML = '<i class="fas fa-table"></i> <span class="toggle-text">Vista Tabella</span>';
                }
                
                // Save preference
                localStorage.setItem('trackingViewMode', currentView);
            });
            
            // Restore saved view
            const savedView = localStorage.getItem('trackingViewMode');
            if (savedView === 'timeline') {
                toggleBtn.click();
            }
        }
        
        // Load Timeline View
        async function loadTimelineView() {
            const timelineContent = document.getElementById('timelineContent');
            timelineContent.innerHTML = '<div class="sol-timeline-loading"><i class="fas fa-spinner fa-spin"></i> Caricamento timeline...</div>';
            
            try {
                // Use data from the existing trackings loaded by tracking/index.js
                const trackings = window.currentTrackings || [];
                
                if (trackings.length === 0) {
                    timelineContent.innerHTML = `
                        <div class="sol-timeline-empty">
                            <i class="fas fa-ship"></i>
                            <p>Nessun tracking da visualizzare</p>
                        </div>
                    `;
                    return;
                }
                
                // Generate timeline HTML
                let timelineHTML = '';
                
                // Group trackings by status for better visualization
                const groupedTrackings = groupTrackingsByStatus(trackings);
                
                for (const [status, statusTrackings] of Object.entries(groupedTrackings)) {
                    if (statusTrackings.length > 0) {
                        timelineHTML += `<div class="sol-timeline-group">
                            <h4 class="sol-timeline-group-title">${getStatusLabel(status)} (${statusTrackings.length})</h4>`;
                        
                        statusTrackings.forEach(tracking => {
                            timelineHTML += generateTrackingTimeline(tracking);
                        });
                        
                        timelineHTML += '</div>';
                    }
                }
                
                timelineContent.innerHTML = timelineHTML;
                
            } catch (error) {
                console.error('Error loading timeline:', error);
                timelineContent.innerHTML = '<div class="sol-timeline-empty">Errore nel caricamento della timeline</div>';
            }
        }
        
        // Group trackings by status
        function groupTrackingsByStatus(trackings) {
            const groups = {
                'delivered': [],
                'in_transit': [],
                'delayed': [],
                'registered': [],
                'exception': []
            };
            
            trackings.forEach(tracking => {
                const status = tracking.status || 'registered';
                if (groups[status]) {
                    groups[status].push(tracking);
                } else {
                    groups['exception'].push(tracking);
                }
            });
            
            return groups;
        }
        
        // Get status label in Italian
        function getStatusLabel(status) {
            const labels = {
                'delivered': 'Consegnati',
                'in_transit': 'In Transito',
                'delayed': 'In Ritardo',
                'registered': 'Registrati',
                'exception': 'Con Problemi'
            };
            return labels[status] || status;
        }
        
        // Generate HTML for tracking timeline
        function generateTrackingTimeline(tracking) {
            let html = `
                <div class="sol-timeline-tracking-card">
                    <div class="sol-tracking-card-header">
                        <div class="sol-tracking-info">
                            <span class="sol-tracking-number">${tracking.tracking_number}</span>
                            <span class="sol-tracking-type">${tracking.tracking_type || 'container'}</span>
                        </div>
                        <span class="sol-tracking-status status-${tracking.status}">${getStatusLabel(tracking.status)}</span>
                    </div>
                    <div class="sol-tracking-details">
                        <div class="sol-tracking-detail">
                            <span class="sol-tracking-detail-label">Vettore</span>
                            <span class="sol-tracking-detail-value">${tracking.carrier_code || 'N/A'}</span>
                        </div>
                        <div class="sol-tracking-detail">
                            <span class="sol-tracking-detail-label">Origine</span>
                            <span class="sol-tracking-detail-value">${tracking.origin_name || tracking.origin_port || 'N/A'}</span>
                        </div>
                        <div class="sol-tracking-detail">
                            <span class="sol-tracking-detail-label">Destinazione</span>
                            <span class="sol-tracking-detail-value">${tracking.destination_name || tracking.destination_port || 'N/A'}</span>
                        </div>
                        <div class="sol-tracking-detail">
                            <span class="sol-tracking-detail-label">ETA</span>
                            <span class="sol-tracking-detail-value">${tracking.eta ? new Date(tracking.eta).toLocaleDateString('it-IT') : 'N/A'}</span>
                        </div>
                    </div>
                `;
            
            // Check for timeline events in metadata
            const timelineEvents = tracking.metadata?.timeline_events || [];
            
            if (timelineEvents.length > 0) {
                // Use real events from metadata
                html += '<div class="sol-timeline-events">';
                
                timelineEvents.forEach((event, index) => {
                    const isLast = index === timelineEvents.length - 1;
                    html += generateTimelineEvent(event, isLast);
                });
                
                html += '</div>';
            } else {
                // Generate demo events based on status
                html += generateDemoTimeline(tracking);
            }
            
            html += '</div>';
            
            return html;
        }
        
        // Generate timeline event HTML
        function generateTimelineEvent(event, isLast) {
            const eventDate = new Date(event.date || event.event_date);
            const eventClass = getEventClass(event.type || event.event_type);
            
            return `
                <div class="sol-timeline-item ${eventClass} ${isLast ? 'last' : ''}">
                    <div class="sol-timeline-event">
                        <div class="sol-timeline-event-header">
                            <span class="sol-timeline-event-title">${event.title || event.description}</span>
                            <span class="sol-timeline-event-date">${eventDate.toLocaleDateString('it-IT')} ${eventDate.toLocaleTimeString('it-IT', {hour: '2-digit', minute:'2-digit'})}</span>
                        </div>
                        ${event.location ? `
                            <div class="sol-timeline-event-location">
                                <i class="fas fa-map-marker-alt"></i>
                                ${event.location}
                            </div>
                        ` : ''}
                        ${event.details ? `<div class="sol-timeline-event-description">${event.details}</div>` : ''}
                    </div>
                </div>
            `;
        }
        
        // Get event class based on type
        function getEventClass(eventType) {
            const typeMap = {
                'DELIVERED': 'delivered',
                'DISCHARGED': 'delivered',
                'LOADED': 'in-transit',
                'DEPARTED': 'in-transit',
                'ARRIVED': 'in-transit',
                'DELAYED': 'delayed',
                'EXCEPTION': 'exception'
            };
            return typeMap[eventType] || '';
        }
        
        // Generate demo timeline (fallback when no real events)
        function generateDemoTimeline(tracking) {
            const events = [];
            const now = new Date();
            
            // Base events on status
            if (tracking.status === 'registered') {
                events.push({
                    title: 'Spedizione Registrata',
                    date: new Date(now - 1 * 24 * 60 * 60 * 1000),
                    location: tracking.origin_name,
                    description: 'Informazioni spedizione ricevute'
                });
            }
            
            if (tracking.status === 'in_transit' || tracking.status === 'delivered') {
                events.push({
                    title: 'Partenza dall\'Origine',
                    date: new Date(now - 5 * 24 * 60 * 60 * 1000),
                    location: tracking.origin_name,
                    description: 'Container caricato e nave partita'
                });
                
                events.push({
                    title: 'In Transito',
                    date: new Date(now - 3 * 24 * 60 * 60 * 1000),
                    location: 'Mare Mediterraneo',
                    description: 'Navigazione in corso'
                });
            }
            
            if (tracking.status === 'delivered') {
                events.push({
                    title: 'Arrivo a Destinazione',
                    date: new Date(now - 2 * 24 * 60 * 60 * 1000),
                    location: tracking.destination_name,
                    description: 'Nave arrivata e container scaricato'
                });
                
                events.push({
                    title: 'Consegnato',
                    date: new Date(now - 1 * 24 * 60 * 60 * 1000),
                    location: tracking.destination_name,
                    description: 'Container consegnato al destinatario',
                    class: 'delivered'
                });
            }
            
            let html = '<div class="sol-timeline-events">';
            
            events.forEach((event, index) => {
                const isLast = index === events.length - 1;
                html += `
                    <div class="sol-timeline-item ${event.class || ''} ${isLast ? 'last' : ''}">
                        <div class="sol-timeline-event">
                            <div class="sol-timeline-event-header">
                                <span class="sol-timeline-event-title">${event.title}</span>
                                <span class="sol-timeline-event-date">${event.date.toLocaleDateString('it-IT')}</span>
                            </div>
                            <div class="sol-timeline-event-location">
                                <i class="fas fa-map-marker-alt"></i>
                                ${event.location}
                            </div>
                            <div class="sol-timeline-event-description">${event.description}</div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            return html;
        }
        
        // Export functions to window for integration
        window.timelineView = {
            init: initViewToggle,
            refresh: loadTimelineView,
            isActive: () => currentView === 'timeline'
        };
        
        // Auto-init on DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initViewToggle);
        } else {
            initViewToggle();
        }
    })();
    </script>

  <!-- SOSTITUISCI il QUICK FIX esistente con questo script più completo -->
<script>
// COMPLETE FIX per Dropdown, Mock Data e Errori 404
document.addEventListener('DOMContentLoaded', function() {
    console.log('[CompleteFix] Starting fixes...');
    
    // 1. CSS Fix AGGRESSIVO per dropdown positioning
    const style = document.createElement('style');
    style.textContent = `
        /* Complete fix for header and dropdown */
        .sol-header {
            position: sticky !important;
            top: 0 !important;
            z-index: 100 !important;
            background: white !important;
        }
        
        .sol-header-content {
            position: relative !important;
            height: 64px !important;
        }
        
        .sol-header-right { 
            position: relative !important; 
            display: flex !important;
            align-items: center !important;
            gap: 1rem !important;
        }
        
        /* FIX PRINCIPALE: dropdown positioning */
        #userDropdown, 
        #notificationDropdown { 
            position: absolute !important; 
            top: calc(100% + 8px) !important;  /* Solo 8px di gap */
            right: 0 !important; 
            left: auto !important;
            margin: 0 !important;  /* Rimuovi margin-top */
            min-width: 280px !important;
            background: white !important;
            border: 1px solid #e5e7eb !important;
            border-radius: 0.5rem !important;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05) !important;
            z-index: 1001 !important;
        }
        
        /* Fix header user button positioning */
        #userMenuBtn {
            position: relative !important;
        }
        
        /* Fix dropdown arrow alignment */
        #userDropdown::before {
            content: '';
            position: absolute;
            top: -6px;
            right: 20px;
            width: 12px;
            height: 12px;
            background: white;
            border-left: 1px solid #e5e7eb;
            border-top: 1px solid #e5e7eb;
            transform: rotate(45deg);
            z-index: 1;
        }
        
        .sol-dropdown-header {
            background: #f9fafb !important;
            padding: 1rem 1.25rem !important;
            border-bottom: 1px solid #e5e7eb !important;
            border-radius: 0.5rem 0.5rem 0 0 !important;
        }
        
        .user-name {
            font-weight: 600 !important;
            margin: 0 0 0.25rem !important;
            color: #111827 !important;
        }
        
        .user-email {
            font-size: 0.875rem !important;
            color: #6b7280 !important;
            margin: 0 !important;
        }
        
        .sol-dropdown-item {
            padding: 0.75rem 1.25rem !important;
        }
        
        .sol-dropdown-item i {
            width: 20px !important;
            text-align: center !important;
            color: #6b7280 !important;
            margin-right: 0.75rem !important;
        }
        
        .sol-dropdown-item:hover {
            background: #f3f4f6 !important;
        }
        
        /* Fix notification dropdown */
        .notification-item {
            padding: 0.75rem 1.25rem !important;
            border-bottom: 1px solid #f3f4f6 !important;
        }
        
        .notification-item:last-child {
            border-bottom: none !important;
        }
        
        /* Fix main content padding */
        .sol-main-content {
            padding-top: calc(64px + 2rem) !important;
        }
    `;
    document.head.appendChild(style);
    
    // 2. Fix Mock Data Interceptors PRIMA che vengano fatte chiamate API
    if (window.MockData && window.MockData.enabled) {
        console.log('[CompleteFix] Setting up mock interceptors...');
        
        // Aspetta che api sia disponibile
        const setupMockApi = () => {
            if (!window.api) {
                setTimeout(setupMockApi, 50);
                return;
            }
            
            // Salva riferimenti originali
            const originalGet = window.api.get.bind(window.api);
            const originalPost = window.api.post.bind(window.api);
            
            // Intercetta GET
            window.api.get = async function(endpoint, options) {
                console.log('[MockAPI] GET request:', endpoint);
                
                // Check mock data PRIMA di fare la richiesta
                const mockData = window.MockData.interceptAPI(endpoint);
                if (mockData) {
                    console.log('[MockAPI] Returning mock data for:', endpoint);
                    await new Promise(resolve => setTimeout(resolve, 200));
                    return mockData;
                }
                
                // Se non c'è mock data, prova la richiesta reale
                try {
                    return await originalGet(endpoint, options);
                } catch (error) {
                    console.error('[MockAPI] Real request failed, returning empty data');
                    // Return empty data invece di fallire
                    if (endpoint.includes('notifications')) {
                        return { notifications: [], unread_count: 0 };
                    }
                    if (endpoint.includes('trackings')) {
                        return { trackings: [], stats: {} };
                    }
                    throw error;
                }
            };
            
            // Intercetta POST
            window.api.post = async function(endpoint, data, options) {
                console.log('[MockAPI] POST request:', endpoint, data);
                
                if (window.MockData.enabled) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    return { success: true, message: 'Mock operation completed', data: data };
                }
                
                return originalPost(endpoint, data, options);
            };
            
            console.log('[CompleteFix] Mock API setup complete');
        };
        
        setupMockApi();
    }
    
    // 3. Fix dropdown event handling
    setTimeout(() => {
        const userDropdown = document.getElementById('userDropdown');
        const notificationDropdown = document.getElementById('notificationDropdown');
        const userMenuBtn = document.getElementById('userMenuBtn');
        const notificationBtn = document.getElementById('notificationBtn');
        
        // Previeni propagazione click dentro dropdown
        [userDropdown, notificationDropdown].forEach(dropdown => {
            if (dropdown) {
                dropdown.addEventListener('click', function(e) {
                    if (!e.target.closest('a') && !e.target.closest('button')) {
                        e.stopPropagation();
                    }
                });
            }
        });
        
        // Fix posizione dropdown quando si apre
        if (userMenuBtn) {
            userMenuBtn.addEventListener('click', function() {
                setTimeout(() => {
                    if (userDropdown && userDropdown.style.display === 'block') {
                        const rect = userMenuBtn.getBoundingClientRect();
                        userDropdown.style.top = `${rect.bottom + 8 - rect.top}px`;
                    }
                }, 10);
            });
        }
        
        console.log('[CompleteFix] Event handlers setup complete');
    }, 1000);
    
    // 4. Force reload notifications con mock data
    setTimeout(() => {
        if (window.headerComponent && window.headerComponent.loadNotifications) {
            console.log('[CompleteFix] Reloading notifications with mock data...');
            window.headerComponent.loadNotifications().catch(err => {
                console.log('[CompleteFix] Notification load error handled:', err.message);
            });
        }
    }, 2000);
});

// 5. Fallback se l'header non si inizializza correttamente
window.addEventListener('load', function() {
    setTimeout(() => {
        // Verifica che il dropdown sia nella posizione giusta
        const dropdown = document.getElementById('userDropdown');
        const button = document.getElementById('userMenuBtn');
        
        if (dropdown && button) {
            // Assicurati che il dropdown sia figlio di sol-header-right
            const headerRight = button.closest('.sol-header-right');
            if (headerRight && !headerRight.contains(dropdown)) {
                console.log('[CompleteFix] Moving dropdown to correct parent...');
                headerRight.appendChild(dropdown);
                
                // Sposta anche il notification dropdown
                const notifDropdown = document.getElementById('notificationDropdown');
                if (notifDropdown && !headerRight.contains(notifDropdown)) {
                    headerRight.appendChild(notifDropdown);
                }
            }
        }
    }, 3000);
});

console.log('[CompleteFix] Fix script loaded');
</script>
</body>
</html>